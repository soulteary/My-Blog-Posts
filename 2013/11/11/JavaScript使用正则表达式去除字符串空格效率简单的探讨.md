# JavaScript使用正则表达式去除字符串空格效率简单的探讨

这个东西大概两周前就写了，不过由于个人状态不佳，没有放出来，今天微博上有童鞋讶异为什么我说常规的`/(^\s*)|(\s*$)/g`效率不是最高的，那么我就来简单的说一下，不过和题目中说的一样，我们是探讨，如果有疑问或者更好的看法不妨提出来。

首先把测试链接发出来，有兴趣的童鞋可以去试一试。

[http://jsperf.com/sy-trim-regexp](http://jsperf.com/sy-trim-regexp "效率测试")

下面是测试代码，详细的说看注释。

```js
var data = [
    '    123',              //前置空格
    '456w    ',             //后置空格
    'JUST test  ',          //中间和后面有空格
    '   this is test   ',   //空格穿插整个字符串
    'hello    test',        //空格仅仅在中间
    'typo',                 //无空格
            '          长颈鹿的脖子那么长 哽咽的时候是不是很难受 章鱼有三颗心脏 心痛的时候是不是很疼 乌鸦可以学人说话 尴尬的时候会不会装咳嗽 骆驼有长长的睫毛 想哭的时候能不能说眼睛进了沙 蛇没有宽宽的肩膀 她累的时候给不了能够依靠的温暖 小强有两个大脑 孤单的时候会不会一起想着谁 我没有长长的脖子 却哽咽的说不出话 我没有三颗心脏 体会不到无法忍受的痛再多三倍 我假装咳嗽 假装被沙子迷了眼 你也没有看我一眼 是因为我太弱小 没有很可靠的肩膀么 无时无刻的清澈想念 一定比两个大脑一起想你还多吧 壁虎有一条会断的尾巴 逃跑的时候是在欺骗对方 还是在伤害自己 你的渐行渐远难道自己就不伤么          '//特别多的字符
    ];

console.log('原始数据', data);
```

先写一个较复杂的匹配规则: `/^\s*(\S*\s*?\S*)\s*$/`

```js
console.log('测试A:');
var regexp = /^\s*(\S*\s*?\S*)\s*$/;
for (var item in data) {
  var val = '原始:|' + data[item] + '|';
  console.log(val);
  var ret = data[item].match(regexp);
  if (ret) {
    ret = ret[1];
    ret = '替换:|' + ret + '|';
    console.log(ret);
  }
}
```

然后是常规的规则: `/(^\s+)|(\s+$)/g`

```js
console.log('测试B:');
var regexp = /(^\s+)|(\s+$)/g;
for (var item in data) {
  var val = '原始:|' + data[item] + '|';
  console.log(val);
  var ret = data[item].replace(regexp, '');
  if (ret) {
    ret = '替换:|' + ret + '|';
    console.log(ret);
  }
}
```

这两个规则的区别一目了然，一个是匹配规则比较多的一次性匹配，一个是规则简单的分组匹配（匹配两次） 如果你打开了文章开头的链接，很容易就可以看出来，匹配规则较多的一次性匹配，比简单的两次匹配的时间快（主要原因CPU计算太快了） 所以，如果要匹配的样本数据不多的时候，一次性匹配规则长度也不太长的话，不要再用分组而是选择用一次性的匹配。 （@玉驰童鞋说过一个例子，说一次性匹配的正则太复杂，以至于CPU跑不动的情况，咱们另外讨论。） 有问题和建议欢迎留言讨论。

---EOF----

